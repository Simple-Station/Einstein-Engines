using System.Linq;
using Content.Client.Pinpointer.UI; // Goobstation
using Content.Client.Resources;
using Content.Client.Viewport;
using Content.Client.UserInterface.Controls;
using Content.Shared.DeviceNetwork; // Goobstation
using Content.Shared.SurveillanceCamera;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Graphics;
using Robust.Shared.Map; // Goobstation
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
using SDL3; // Goobstation

namespace Content.Client.SurveillanceCamera.UI;

[GenerateTypedNameReferences]
public sealed partial class SurveillanceCameraMonitorWindow : FancyWindow // Goobstation
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;
    [Dependency] private IEntityManager _entManager = default!; // Goobstation

    public event Action<string>? CameraSelected;
    public event Action<string>? SubnetOpened;
    public event Action? CameraRefresh;
    public event Action? SubnetRefresh;
    public event Action? CameraSwitchTimer;
    public event Action? CameraDisconnect;

    private string _currentAddress = string.Empty;
    private bool _isSwitching;
    private readonly FixedEye _defaultEye = new();
    private readonly SpriteSystem _spriteSystem; // Goobstation
    private readonly Dictionary<NetEntity, string> _reverseCameras = new(); // Goobstation

    public SurveillanceCameraMonitorWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _spriteSystem = _entManager.System<SpriteSystem>(); // Goobstation

        // This could be done better. I don't want to deal with stylesheets at the moment.
        var texture = _resourceCache.GetTexture("/Textures/Interface/Nano/square_black.png");
        var shader = _prototypeManager.Index<ShaderPrototype>("CameraStatic").Instance().Duplicate();

        CameraView.ViewportSize = new Vector2i(770, 770);
        CameraView.Eye = _defaultEye; // sure
        CameraViewBackground.Stretch = TextureRect.StretchMode.Scale;
        CameraViewBackground.Texture = texture;
        CameraViewBackground.ShaderOverride = shader;

        // Set trackable entity selection action - Camera Selection
        NavMap.TrackedEntitySelectedAction += SetTrackedEntityFromNavMap; // Goobstation

        SubnetRefreshButton.OnPressed += _ => SubnetRefresh!();
        CameraRefreshButton.OnPressed += _ => CameraRefresh!();
        CameraDisconnectButton.OnPressed += _ => CameraDisconnect!();
    }

    // Goobstation start

    // need to translate entity to string and then call the same method the list does
    private void SetTrackedEntityFromNavMap(NetEntity? netEntity)
    {
        if (!netEntity.HasValue)
            return;

        CameraSelected!(_reverseCameras[netEntity.Value]);
    }

    public EntityUid Entity;

    // Needed for NavMap to initialize and draw the grid
    public void SetEntity(EntityUid uid)
    {
        Entity = uid;

        // Pass owner to nav map
        NavMap.Owner = uid;

        // Set nav map grid uid
        var stationName = Loc.GetString("surveillance-camera-monitor-ui-unknown-location");

        if (_entManager.TryGetComponent<TransformComponent>(uid, out var xform))
        {
            NavMap.MapUid = xform.GridUid;

            // Assign station name
            if (_entManager.TryGetComponent<MetaDataComponent>(xform.GridUid, out var stationMetaData))
                stationName = stationMetaData.EntityName;

            var msg = new FormattedMessage();
            msg.AddMarkupOrThrow(Loc.GetString("surveillance-camera-monitor-ui-station-name", ("stationName", stationName)));

            StationName.SetMessage(msg);
        }

        else
        {
            StationName.SetMessage(stationName);
            NavMap.Visible = false;
        }
    }

    // Add a particular camera
    private void AddTrackedEntityToNavMap(NetEntity ent, NetCoordinates coordinates, bool selected)
    {
        var coords = _entManager.GetCoordinates(coordinates);
        var texture = new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_square.png"));
        var color = selected ? Color.Green : Color.Red;
        var blink = false;
        var modulator = Color.White;

        var blip = new NavMapBlip(coords, _spriteSystem.Frame0(texture), color * modulator, blink);
        NavMap.TrackedEntities[ent] = blip;
    }

    // The UI class should get the eye from the entity, and then
    // pass it here so that the UI can change its view.
    public void UpdateState(IEye? eye, string activeAddress, Dictionary<string, (NetEntity, NetCoordinates)> cameras) // Goobstation
    {
        _currentAddress = activeAddress;
        SetCameraView(eye);

        // Goobstation Start
        _reverseCameras.Clear();
        NavMap.TrackedEntities.Clear();
        foreach (var (camera, (ent, coordinates)) in cameras)
        {
            _reverseCameras[ent] = camera;
            AddTrackedEntityToNavMap(ent, coordinates, camera.Equals(_currentAddress) ? true : false);
        }
    }

    private void SetCameraView(IEye? eye)
    {
        var eyeChanged = eye != CameraView.Eye || CameraView.Eye == null;
        CameraView.Eye = eye ?? _defaultEye;
        CameraView.Visible = !eyeChanged && !_isSwitching;
        CameraDisconnectButton.Disabled = eye == null;

        if (eye != null)
        {
            if (!eyeChanged)
            {
                return;
            }

            _isSwitching = true;
            CameraViewBackground.Visible = true;
            CameraStatus.Text = Loc.GetString("surveillance-camera-monitor-ui-status",
                ("status", Loc.GetString("surveillance-camera-monitor-ui-status-connecting")),
                ("address", _currentAddress));
            CameraSwitchTimer!();
        }
        else
        {
            CameraViewBackground.Visible = true;
            CameraStatus.Text = Loc.GetString("surveillance-camera-monitor-ui-status-disconnected");
        }
    }

    public void OnSwitchTimerComplete()
    {
        _isSwitching = false;
        CameraView.Visible = CameraView.Eye != _defaultEye;
        CameraViewBackground.Visible = CameraView.Eye == _defaultEye;
        CameraStatus.Text = Loc.GetString("surveillance-camera-monitor-ui-status",
                            ("status", Loc.GetString("surveillance-camera-monitor-ui-status-connected")),
                            ("address", _currentAddress));
    }
}
