using System.Linq;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using static Content.Client.Stylesheets.StyleBase;
using static Robust.Shared.Maths.Direction;

namespace Content.Client.UserInterface.Controls;

/// A simple yet good-looking configurable tab container using normal UI elements
[GenerateTypedNameReferences]
public sealed partial class NeoTabContainer : BoxContainer
{
    private readonly Dictionary<Control, TabInfo> _tabs = new();
    private readonly List<Control> _controls = new();
    private readonly ButtonGroup _tabGroup = new(false);

    /// All children within the <see cref="ContentContainer"/>
    public OrderedChildCollection Contents => ContentContainer.Children;

    public Control? CurrentControl { get; private set; }
    public TabInfo? CurrentTab => _tabs!.GetValueOrDefault(CurrentControl);

    /// Calls an init event on the current tab when switching to it if not done before
    public bool LazyLoading { get; set; } = true;


    /// <inheritdoc cref="NeoTabContainer"/>
    public NeoTabContainer()
    {
        RobustXamlLoader.Load(this);

        LayoutChanged(TabLocation);
        ScrollingChanged(HScrollEnabled, VScrollEnabled);
    }

    protected override void ChildRemoved(Control child)
    {
        if (_tabs.Remove(child, out var info))
            info.Button.Dispose();

        // Set the current tab to a different control
        if (CurrentControl == child)
        {
            var previous = _controls.IndexOf(child) - 1;

            if (previous > -1)
                SelectTab(_controls[previous]);
            else
                CurrentControl = null;
        }

        _controls.Remove(child);
        base.ChildRemoved(child);
        UpdateTabMerging();
    }

    // A fun display of every location for the tabs if you want it
    // private TimeSpan _lastLayoutChange = TimeSpan.Zero;
    // private TimeSpan _nextLayoutChange = TimeSpan.Zero;
    // protected override void FrameUpdate(FrameEventArgs args)
    // {
    //     base.FrameUpdate(args);
    //
    //     _lastLayoutChange += TimeSpan.FromSeconds(args.DeltaSeconds);
    //     // Change the layout every second such that the tabs go in a circle
    //     if (_lastLayoutChange.TotalSeconds < _nextLayoutChange.TotalSeconds)
    //         return;
    //
    //     _lastLayoutChange = _nextLayoutChange;
    //     _nextLayoutChange = _lastLayoutChange + TimeSpan.FromSeconds(2);
    //
    //     LayoutChanged(TabLocation switch
    //     {
    //         North => East,
    //         East => South,
    //         South => West,
    //         West => North,
    //         _ => North,
    //     });
    // }


    /// <summary>
    ///     Adds a tab to this container
    /// </summary>
    /// <param name="control">The tab contents</param>
    /// <param name="title">The title of the tab</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>The index of the new tab</returns>
    public int AddTab(Control control, string? title, bool updateTabMerging = true, Action? initialize = null)
    {
        var button = new Button
        {
            Group = _tabGroup,
            MinHeight = 32,
            MaxHeight = 32,
            HorizontalExpand = true,
        };
        button.OnPressed += _ => SelectTab(control);
        if (!string.IsNullOrEmpty(title))
            button.Text = title;

        TabContainer.AddButton(button);
        ContentContainer.AddChild(control);
        _controls.Add(control);
        _tabs.Add(control, new(control, button));

        TrySetTabInitialize(control, initialize);
        if (!LazyLoading)
        {
            _tabs[control].Initialize?.Invoke();
            _tabs[control].Initialized = true;
        }

        // Show it if it has content
        if (ContentContainer.ChildCount > 1)
            control.Visible = false;
        else
            // Select it if it's the only tab
            SelectTab(control);

        if (updateTabMerging)
            UpdateTabMerging();

        return ChildCount - 1;
    }

    /// <summary>
    ///     Disposes the tab associated with the given index
    /// </summary>
    /// <param name="index">The index of the tab to remove</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>True if the tab was removed, false otherwise</returns>
    public bool RemoveTab(int index, bool updateTabMerging = true)
    {
        if (index < 0 || index >= _controls.Count)
            return false;

        var control = _controls[index];
        RemoveTab(control, updateTabMerging);
        return true;
    }

    /// <summary>
    ///     Disposes the tab associated with the given control
    /// </summary>
    /// <param name="control">The control to remove</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>True if the tab was removed, false otherwise</returns>
    public bool RemoveTab(Control control, bool updateTabMerging = true)
    {
        if (!_tabs.TryGetValue(control, out var info))
            return false;

        info.Button.Dispose();
        control.Dispose();
        _controls.Remove(control);
        _tabs.Remove(control);
        if (updateTabMerging)
            UpdateTabMerging();
        return true;
    }

    public TabInfo GetTabInfo(int index) => _tabs[_controls[index]];
    public TabInfo GetTabInfo(Control control) => _tabs[control];

    public void TrySetTabInitialize(int index, Action? initialize)
    {
        if (index < 0 || index >= _controls.Count)
            return;

        var control = _controls[index];
        TrySetTabInitialize(control, initialize);
    }
    public void TrySetTabInitialize(Control control, Action? initialize)
    {
        if (!_tabs.TryGetValue(control, out var info))
            return;

        if (info.Initialize != null)
            info.Initialize += initialize;
        else
            info.Initialize = initialize;
    }


    /// Sets the title of the tab associated with the given index
    public void SetTabTitle(int index, string title)
    {
        if (index < 0 || index >= _controls.Count)
            return;

        var control = _controls[index];
        SetTabTitle(control, title);
    }

    /// Sets the title of the tab associated with the given control
    public void SetTabTitle(Control control, string title)
    {
        if (!_tabs.TryGetValue(control, out var info))
            return;

        if (info.Button is Button b)
            b.Text = title;
    }

    /// Shows or hides the tab associated with the given index
    public void SetTabVisible(int index, bool visible)
    {
        if (index < 0 || index >= _controls.Count)
            return;

        var control = _controls[index];
        SetTabVisible(control, visible);
    }

    /// Shows or hides the tab associated with the given control
    public void SetTabVisible(Control control, bool visible)
    {
        if (!_tabs.TryGetValue(control, out var info))
            return;

        info.Button.Visible = visible;
        UpdateTabMerging();
    }

    /// Selects the tab associated with the control
    public void SelectTab(Control control)
    {
        if (CurrentControl != null)
            CurrentControl.Visible = false;

        var info = _tabs[control];
        if (!info.Initialized)
        {
            info.Initialize?.Invoke();
            info.Initialized = true;
        }

        info.Button.Pressed = true;
        control.Visible = true;
        CurrentControl = control;
    }

    /// Sets the style of every visible tab's Button to be Open to Right, Both, or Left depending on position
    public void UpdateTabMerging() => TabContainer.UpdateStyles();
}

public sealed class TabInfo(Control control, BaseButton button)
{
    public Control Control { get; } = control;
    public BaseButton Button { get; } = button;
    public bool Initialized { get; set; }
    public Action? Initialize { get; set; }
}
