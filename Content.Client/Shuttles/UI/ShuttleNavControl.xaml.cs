using System.Collections.Concurrent;
using System.Numerics;
using Content.Client.Crescent.Radar;
using Content.Client.Station;
using Content.Shared._Crescent.ShipShields;
using Content.Shared._Crescent.Vessel;
using Content.Shared.Crescent.Radar; // Frontier
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using JetBrains.Annotations;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Collision.Shapes;
using Robust.Shared.Physics.Components;
using Robust.Shared.Physics.Systems;
using Robust.Shared.Threading;


namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
public sealed partial class ShuttleNavControl : BaseShuttleControl
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    [Dependency] private readonly IUserInterfaceManager _uiManager = default!;
    [Dependency] private readonly IParallelManager _parMan = default!;
    [Dependency] private readonly ILocalizationManager _locMan = default!;
    private readonly StationSystem _station; // Frontier
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _transform;
    private readonly ProjectileIFFSystem _projectileIFF;
    private readonly FixtureSystem _fixtures;
    private readonly SpriteSystem _sprites;

    /// <summary>
    /// Used to transform all of the radar objects. Typically is a shuttle console parented to a grid.
    /// </summary>
    private EntityCoordinates? _coordinates;

    private Angle? _rotation;

    private Dictionary<NetEntity, List<DockingPortState>> _docks = new();
    private List<ProjectileState> _projectiles = new();
    private Dictionary<NetEntity, List<TurretState>> _turrets = new();

    internal int updateTicker = 0;

    private ShuttleCalculatePositionsJob drawJob;

    public bool ShowIFF { get; set; } = true;
    public bool ShowDocks { get; set; } = true;

    /// <summary>
    /// Raised if the user left-clicks on the radar control with the relevant entitycoordinates.
    /// </summary>
    public Action<EntityCoordinates>? OnRadarClick;
    public Action? OnRadarRelease;
    public Action<EntityCoordinates>? OnRadarMouseMove;
    public Action<Angle>? OnRadarMouseMoveRelative;
    // Represents where the mouse would physically be in the game world. Only updates when the mouse is over the UI.
    private Vector2 MousePosition = Vector2.Zero;
    private Vector2 MouseUIPosition = Vector2.Zero;
    private Angle LastRotation = Angle.Zero;
    private Vector2 LastWorldCoordinates = Vector2.Zero;
    public bool keepWorldAligned = false;
    private List<Entity<MapGridComponent>> _grids = new();

    #region  HullrotShipShit
    internal record shipData
    {
        public MapGridComponent comp;
        public bool forceShow;
        public Vector2 UIPosition;
        public Texture? icon;
        public int WidthRequired;
        public int HeightRequired;
        public Vector2 textureOffset;
        public Vector2 calculatedUiPositionIcon;
        public Vector2 calcultedUiPositionText;

        public shipData(MapGridComponent comp, Vector2 uiPosition)
        {
            this.comp = comp;
            this.UIPosition = uiPosition;
            this.forceShow = false;
        }
    }
    private record struct ShuttleCalculatePositionsJob : IParallelRobustJob
    {
        // modify in the future to use multiple drawing handles incase more objects get added(to prevent multi-threaded rendering artifacts) SPCR 2025
        public int BatchSize => 99999;

        public ShuttleNavControl control;
        public IEntityManager EntManager;
        public SharedShuttleSystem ShuttlesSys;
        public SharedTransformSystem TransformSys;
        public FixtureSystem fixturesSys;
        public SpriteSystem spritesSys;

        public EntityQuery<TransformComponent> xformQuery;
        public EntityQuery<FixturesComponent> fixturesQuery;
        public EntityQuery<PhysicsComponent> bodyQuery;
        public EntityQuery<VesselIconComponent> iconQuery;

        public bool ShowIFF;
        public bool ShowDocks;
        public Box2 viewAABB;
        public Angle rot;
        public MapCoordinates mapPos;
        public Vector2 MidPointVector;
        public Vector2 MousePositionOnUi;
        public int PixelWidth;
        public int PixelHeight;
        public Font Font;
        public float MinimapScale;

        public EntityUid selfGrid;
        public Matrix3x2 selfWorldMatrixInvert;
        public List<Entity<MapGridComponent>> grids;
        public ConcurrentBag<Entity<MapGridComponent>> closeGrids;
        public ConcurrentDictionary<EntityUid, shipData> gridData;
        public DrawingHandleScreen handle;
        public ILocalizationManager Loc;
        public void Execute(int index)
        {
            var gUid = grids[index].Owner;
            var gComp = grids[index].Comp;
            if (gUid == selfGrid || !fixturesQuery.HasComponent(gUid))
                return;

            var gridBody = bodyQuery.GetComponent(gUid);
            EntManager.TryGetComponent<IFFComponent>(gUid, out var iff);

            if (!ShuttlesSys.CanDraw(gUid, gridBody, iff))
                return;

            var labelName = ShuttlesSys.GetIFFLabel(gUid, self: false, iff);
            var gridMatrix = TransformSys.GetWorldMatrix(gUid);
            var matty = Matrix3x2.Multiply(gridMatrix, selfWorldMatrixInvert);
            var color = ShuttlesSys.GetIFFColor(gUid, self: false, iff);
            shipData data;
            if (!gridData.ContainsKey(gUid))
            {
                data = new shipData(gComp, Vector2.Zero);
                if (iconQuery.TryComp(gUid, out var vesselIcon) && vesselIcon.Icon != null)
                {
                    data.icon =  spritesSys.Frame0(vesselIcon.Icon);
                    data.HeightRequired = data.icon.Height / 2;
                    data.WidthRequired = data.icon.Width / 2;
                    data.textureOffset = new Vector2(-data.icon.Width, -data.icon.Height);
                    data.textureOffset /= 2;
                }
                gridData[gUid] = data;
            }
            else
            {
                data = gridData[gUid];
            }


            if (ShowIFF && data.forceShow)
                color = Color.DarkRed;
            var gridAABB = gridMatrix.TransformBox(gComp.LocalAABB);
            if (gridAABB.Intersects(viewAABB))
            {
                closeGrids.Add(grids[index]);
                return;
            }

            //.2 NOTE: this code handles the ship dots and icons at the edge of your nav screen
            // this is likely where the ship icons not showing up is handled
            if (labelName != null && labelName !="grid" && !gridAABB.Intersects(viewAABB) && ShowIFF) //.2 | 2025 - edit to make exploded/generated grids not spam ur radar screen
            {
                const float ShipSelectionDotRadius = 1f;
                float xSpaceRequired = ShipSelectionDotRadius;
                float ySpaceRequired = ShipSelectionDotRadius;
                Texture? icon = null;
                Vector2 textureOffset = Vector2.Zero;
                if (data.icon is not null)
                {
                    icon = data.icon;
                    textureOffset = data.textureOffset;
                    xSpaceRequired = data.WidthRequired;
                    ySpaceRequired = data.HeightRequired;
                }

                // transform vector from worldPosition to UIPosition.
                Vector2 targetPos = control.ResolveUIPosition(rot, TransformSys.GetWorldPosition(gUid), mapPos.Position, new Vector2(xSpaceRequired, ySpaceRequired));
                //handle.DrawLine(MidPointVector, ScalePosition(UIPosVector), Color.AntiqueWhite);
                var gridCentre = Vector2.Transform(gridBody.LocalCenter, matty);
                gridCentre.Y = -gridCentre.Y;
                var distance = gridCentre.Length();
                // yes 1.0 scale is intended here.
                var labelText = Loc.GetString(
                    "shuttle-console-iff-label",
                    ("name", labelName),
                    ("distance", $"{distance:0.0}"));
                var labelDimensions = handle.GetDimensions(Font, labelText, 1f);
                Vector2 textUiPosition = new Vector2(-labelDimensions.X / 2f, 0);
                if (data.forceShow)
                    color = Color.DarkRed;

                if ((targetPos - MousePositionOnUi).Length() < 10 || distance < 512 || data.forceShow)
                {
                    textUiPosition += targetPos;
                    textUiPosition.X = Math.Clamp(textUiPosition.X, 0f, PixelWidth - labelDimensions.X);
                    textUiPosition.Y = Math.Clamp(textUiPosition.Y, 0f, PixelHeight - labelDimensions.Y);
                    handle.DrawString(Font, textUiPosition, labelText, color);
                }
                if (icon is not null)
                    handle.DrawTexture(icon, targetPos + textureOffset, color);
                else
                    handle.DrawCircle(targetPos, ShipSelectionDotRadius, color, true);
                data.UIPosition = targetPos;

            }
        }
    }

    #endregion
    public ShuttleNavControl() : base(64f, 256f, 256f)
    {
        RobustXamlLoader.Load(this);
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _transform = EntManager.System<SharedTransformSystem>();
        _station = EntManager.System<StationSystem>(); // Frontier
        _projectileIFF = EntManager.System<ProjectileIFFSystem>();
        _fixtures = EntManager.System<FixtureSystem>();
        _sprites = EntManager.System<SpriteSystem>();
        drawJob = new ShuttleCalculatePositionsJob()
        {
            EntManager = EntManager,
            ShuttlesSys = _shuttles,
            TransformSys = _transform,
            fixturesSys = _fixtures,
            spritesSys = _sprites,
            Loc = _locMan,
            xformQuery = EntManager.GetEntityQuery<TransformComponent>(),
            fixturesQuery = EntManager.GetEntityQuery<FixturesComponent>(),
            bodyQuery = EntManager.GetEntityQuery<PhysicsComponent>(),
            iconQuery = EntManager.GetEntityQuery<VesselIconComponent>(),
            closeGrids = new ConcurrentBag<Entity<MapGridComponent>>(),
            gridData = new ConcurrentDictionary<EntityUid, shipData>(),
            control = this,
        };

    }

    public void SetMatrix(EntityCoordinates? coordinates, Angle? angle)
    {
        _coordinates = coordinates;
        _rotation = angle;
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (_coordinates == null || _rotation == null || args.Function != EngineKeyFunctions.UIClick ||
            OnRadarClick == null)
        {
            return;
        }

        var a = InverseScalePosition(args.RelativePosition);
        var relativeWorldPos = new Vector2(a.X, -a.Y);
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        var coords = _coordinates.Value.Offset(relativeWorldPos);
        OnRadarClick?.Invoke(coords);
        OnRadarRelease?.Invoke();
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (_coordinates == null || _rotation == null || args.Function != EngineKeyFunctions.UIClick)
            return;

        OnRadarClick?.Invoke(PureRelativePosition(args.RelativePosition));
        foreach (var (shipkey, shipdata) in drawJob.gridData)
        {
            if ((shipdata.UIPosition - MouseUIPosition).Length() < 5)
            {
                shipdata.forceShow = !shipdata.forceShow;
            }
        }
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        var returned = PureRelativePosition(args.RelativePosition);

        OnRadarMouseMove?.Invoke(returned);
        OnRadarMouseMoveRelative?.Invoke(RelativeAngleFromFace(returned));
    }

    private EntityCoordinates RelativePositionToEntityCoords(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;

        var a = InverseScalePosition(pos);
        var relativeWorldPos = a with { Y = -a.Y };
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        return _coordinates.Value.Offset(relativeWorldPos);

    }
    // SPCR 2024 - This is only used for shooting ship weapons. The function above is ... not accurate
    // for objects with a width and height of 0 (aka bullets)
    public EntityCoordinates PureRelativePosition(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;
        var trueSize = Size;
        var a = ((pos - (trueSize/2))*2)/Size * ActualRadarRange;
        var relativePos = a with { Y = -a.Y };
        relativePos = _rotation.Value.RotateVec(relativePos);
        var gridRotation = _transform.GetWorldRotation(_coordinates.Value.EntityId);
        if (keepWorldAligned)
            gridRotation = Angle.Zero;
        MousePosition = gridRotation.RotateVec(relativePos) + _transform.ToMapCoordinates(_coordinates.Value).Position;
        return _coordinates.Value.Offset(relativePos);
    }

    public EntityCoordinates PureRelativePositionWithoutSetter(Vector2 pos)
    {
        if (_coordinates == null || _rotation == null)
            return EntityCoordinates.Invalid;
        var trueSize = Size;
        var a = ((pos - (trueSize/2))*2)/Size * ActualRadarRange;
        var relativePos = a with { Y = -a.Y };
        relativePos = _rotation.Value.RotateVec(relativePos);
        return _coordinates.Value.Offset(relativePos);
    }

    // COnverts relative entity coordinates to relative angle. - on the left side , + on the right side.
    public Angle RelativeAngleFromFace(EntityCoordinates relPos)
    {
        var args = Angle.FromWorldVec(relPos.Position);
        return args < Angle.FromDegrees(0)
            ? new Angle(-(Math.PI + args.Theta))
            : (args > Angle.FromDegrees(270) ? args : (Math.PI - args));
    }

    /// <summary>
    /// Gets the entitycoordinates of where the mouseposition is, relative to the control.
    /// </summary>
    [PublicAPI]
    public EntityCoordinates GetMouseCoordinates(ScreenCoordinates screen)
    {
        if (_coordinates == null || _rotation == null)
        {
            return EntityCoordinates.Invalid;
        }

        var pos = screen.Position / UIScale - GlobalPosition;

        var a = InverseScalePosition(pos);
        var relativeWorldPos = new Vector2(a.X, -a.Y);
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        var coords = _coordinates.Value.Offset(relativeWorldPos);
        return coords;
    }

    public void UpdateState(IFFInterfaceState state)
    {
        _projectiles = state.Projectiles;
        _turrets = state.Turrets;
    }

    public void UpdateState(NavInterfaceState state)
    {
        SetMatrix(EntManager.GetCoordinates(state.Coordinates), new Angle(state.Angle));
        keepWorldAligned = state.AlignToWorld;
        if (keepWorldAligned)
        {
            _rotation = Angle.Zero;
        }
        WorldMaxRange = state.MaxRange;

        if (WorldMaxRange < WorldRange)
        {
            ActualRadarRange = WorldMaxRange;
        }

        if (WorldMaxRange < WorldMinRange)
            WorldMinRange = WorldMaxRange;

        ActualRadarRange = Math.Clamp(ActualRadarRange, WorldMinRange, WorldMaxRange);

        _docks = state.Docks;

        NfUpdateState(state); // Frontier Update State
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        DrawBacking(handle);
        DrawCircles(handle);

        // No data
        if (_coordinates == null || _rotation == null)
        {
            return;
        }

        updateTicker++;

        var xformQuery = EntManager.GetEntityQuery<TransformComponent>();
        var fixturesQuery = EntManager.GetEntityQuery<FixturesComponent>();
        var bodyQuery = EntManager.GetEntityQuery<PhysicsComponent>();

        if (!xformQuery.TryGetComponent(_coordinates.Value.EntityId, out var xform)
            || xform.MapID == MapId.Nullspace)
        {
            return;
        }

        var mapPos = _transform.ToMapCoordinates(_coordinates.Value);
        var offset = _coordinates.Value.Position;
        var posMatrix = Matrix3Helpers.CreateTransform(offset, _rotation.Value);
        var (_, ourEntRot, ourEntMatrix) = _transform.GetWorldPositionRotationMatrix(_coordinates.Value.EntityId);
        var rot = ourEntRot + _rotation.Value;
        if (keepWorldAligned)
        {
            ourEntRot = Angle.Zero;
            rot = Angle.Zero;
            ourEntMatrix = Matrix3Helpers.CreateTransform(mapPos.Position, Angle.Zero);
            posMatrix = Matrix3Helpers.CreateTransform(Vector2.One, Angle.Zero);
            offset = Vector2.Zero;
        }

        var ourWorldMatrix = Matrix3x2.Multiply(posMatrix, ourEntMatrix);
        Matrix3x2.Invert(ourWorldMatrix, out var ourWorldMatrixInvert);

        var vert = (MousePosition - mapPos.Position) ;
        // position compensation
        if (LastWorldCoordinates != Vector2.Zero)
        {
            MousePosition += mapPos.Position - LastWorldCoordinates;
        }
        // rotational compensation
        if (LastRotation != Angle.Zero)
        {
            MousePosition = mapPos.Position + (ourEntRot - LastRotation).RotateVec(MousePosition - mapPos.Position);
        }

        LastRotation = ourEntRot;

        vert.Y = -vert.Y;
        vert = rot.RotateVec(vert);
        vert = ScalePosition(vert);
        MouseUIPosition = vert;
        if(updateTicker > 10)
            OnRadarMouseMove?.Invoke(PureRelativePositionWithoutSetter(vert));
        LastWorldCoordinates = mapPos.Position;
        //vert = (Angle.FromDegrees(180) - ourEntRot).RotateVec(vert);
        //Logger.Debug($"{vert.X} , {vert.Y}");

        handle.DrawCircle(vert, 5f, Color.White, false);
        if (!keepWorldAligned)
        {
            var northRot = ourEntRot + _rotation.Value;
            DrawNorthLine(handle, northRot);
        }

        var movementVector = bodyQuery.GetComponent(_coordinates.Value.EntityId).LinearVelocity;
        movementVector.Y *= -1;
        movementVector = ourEntRot.RotateVec(movementVector);
        movementVector = ScalePosition(movementVector);

        handle.DrawLine(MidPointVector, movementVector, Color.Red);

        // Draw our grid in detail
        var ourGridId = xform.GridUid;
        if (EntManager.TryGetComponent<MapGridComponent>(ourGridId, out var ourGrid) &&
            fixturesQuery.HasComponent(ourGridId.Value))
        {
            var ourGridMatrix = _transform.GetWorldMatrix(ourGridId.Value);
            var matrix = Matrix3x2.Multiply(ourGridMatrix, ourWorldMatrixInvert);
            var color = _shuttles.GetIFFColor(ourGridId.Value, self: true);

            DrawGrid(handle, matrix, (ourGridId.Value, ourGrid), color);
            DrawDocks(handle, ourGridId.Value, matrix);
            DrawTurrets(handle, ourGridId.Value, matrix, true);
        }

        DrawProjectiles(handle, ourWorldMatrixInvert);
        DrawShields(handle, xform, ourWorldMatrixInvert);


        var invertedPosition = _coordinates.Value.Position - offset;
        invertedPosition.Y = -invertedPosition.Y;
        // Don't need to transform the InvWorldMatrix again as it's already offset to its position.

        // Draw radar position on the station
        var radarPos = invertedPosition;
        const float radarVertRadius = 2f;

        var radarPosVerts = new Vector2[]
        {
            ScalePosition(radarPos + new Vector2(0f, -radarVertRadius)),
            ScalePosition(radarPos + new Vector2(radarVertRadius / 2f, 0f)),
            ScalePosition(radarPos + new Vector2(0f, radarVertRadius)),
            ScalePosition(radarPos + new Vector2(radarVertRadius / -2f, 0f)),
        };

        handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, radarPosVerts, Color.Lime);

        var viewBounds = new Box2Rotated(new Box2(-WorldRange, -WorldRange, WorldRange, WorldRange).Translated(mapPos.Position), rot, mapPos.Position);
        var viewAABB = viewBounds.CalcBoundingBox();

        _grids.Clear();
        _mapManager.FindGridsIntersecting(xform.MapID, new Box2(mapPos.Position - MaxRadarRangeVector, mapPos.Position + MaxRadarRangeVector), ref _grids, approx: true, includeMap: false);
        if(ourGridId is not null)
            drawJob.selfGrid = ourGridId.Value;
        drawJob.MidPointVector = MidPointVector;
        drawJob.MinimapScale = MinimapScale;
        drawJob.Font = Font;
        drawJob.grids = _grids;
        drawJob.handle = handle;
        drawJob.rot = rot;
        drawJob.PixelHeight = PixelHeight;
        drawJob.PixelWidth = PixelWidth;
        drawJob.selfWorldMatrixInvert = ourWorldMatrixInvert;
        drawJob.mapPos = mapPos;
        drawJob.viewAABB = viewAABB;
        drawJob.ShowDocks = ShowDocks;
        drawJob.ShowIFF = ShowIFF;
        drawJob.MousePositionOnUi = vert;
        drawJob.closeGrids.Clear();
        _parMan.ProcessNow(drawJob, _grids.Count);

        // Draw other grids... differently
        foreach (var grid in drawJob.closeGrids)
        {
            var gUid = grid.Owner;
            if (gUid == ourGridId || !fixturesQuery.HasComponent(gUid))
                continue;

            var gridBody = bodyQuery.GetComponent(gUid);
            EntManager.TryGetComponent<IFFComponent>(gUid, out var iff);

            if (!_shuttles.CanDraw(gUid, gridBody, iff))
                continue;

            var gridMatrix = _transform.GetWorldMatrix(gUid);
            var matty = Matrix3x2.Multiply(gridMatrix, ourWorldMatrixInvert);
            var color = _shuttles.GetIFFColor(grid, self: false, iff);

            if (ShowIFF && drawJob.gridData[gUid].forceShow)
                color = Color.DarkRed;
            // Others default:
            // Color.FromHex("#FFC000FF")
            // Hostile default: Color.Firebrick
            var labelName = _shuttles.GetIFFLabel(grid, self: false, iff);
            var gridCentre = Vector2.Transform(gridBody.LocalCenter, matty);
            var gridBounds = grid.Comp.LocalAABB;

            gridCentre.Y = -gridCentre.Y;
            var distance = gridCentre.Length();
            if (ShowIFF && labelName != null && labelName != "grid") //.2 edit: grids dont show up as labels anymore finally
            {
                var labelText = Loc.GetString(
                    "shuttle-console-iff-label",
                    ("name", labelName),
                    ("distance", $"{distance:0.0}"));

                // yes 1.0 scale is intended here.
                var labelDimensions = handle.GetDimensions(Font, labelText, 1f);

                // y-offset the control to always render below the grid (vertically)
                var yOffset = Math.Max(gridBounds.Height, gridBounds.Width) * MinimapScale / 1.8f;

                // The actual position in the UI. We offset the matrix position to render it off by half its width
                // plus by the offset.
                var uiPosition = ScalePosition(gridCentre) - new Vector2(labelDimensions.X / 2f, -yOffset);

                // Look this is uggo so feel free to cleanup. We just need to clamp the UI position to within the viewport.
                uiPosition = new Vector2(
                    Math.Clamp(uiPosition.X, drawJob.gridData[grid.Owner].HeightRequired, PixelWidth - labelDimensions.X),
                    Math.Clamp(uiPosition.Y, 0f, PixelHeight - labelDimensions.Y));
                handle.DrawString(Font, uiPosition, labelText, color);
            }

            DrawGrid(handle, matty, grid, color);
            DrawDocks(handle, gUid, matty);
            DrawTurrets(handle, gUid, matty, false);

        }

        if (ourGrid is null)
            return;
        DrawIFFDesignatedObjects(handle, ourWorldMatrix, ourGrid, viewAABB);
    }

    public Vector2 ResolveUIPosition(Angle rotation, Vector2 gridWorldPos, Vector2 selfPos, Vector2 spaceRequired)
    {
        Vector2 UIPosVector = (-rotation).RotateVec(gridWorldPos - selfPos);
        UIPosVector.Y *= -1;
        // get its direction.
        Vector2 UIDirection = UIPosVector.Normalized();
        // collision with oY axis.
        Vector2 YTargetScaled = MidPointVector +
            UIPosVector.Normalized() * Math.Abs((MidPointVector.X - spaceRequired.X) / UIDirection.Y);
        // collision with oX axis
        Vector2 XTargetScaled = MidPointVector +
            UIPosVector.Normalized() * Math.Abs((MidPointVector.Y - spaceRequired.Y) / UIDirection.X);
        // fucked up maths case!! SPCR
        if (YTargetScaled.X < 0)
            YTargetScaled = XTargetScaled;
        if (XTargetScaled.Y < 0)
            XTargetScaled = YTargetScaled;
        if (YTargetScaled.Length() < XTargetScaled.Length())
            return YTargetScaled;
        return XTargetScaled;
    }
    private void DrawIFFDesignatedObjects(DrawingHandleScreen handle, Matrix3x2 gridMat, MapGridComponent grid, Box2 viewAABB)
    {
        var targets = EntManager.EntityQueryEnumerator<EntityIFFDesignationComponent>();
        var gridAABB = gridMat.TransformBox(grid.LocalAABB);
        if (gridAABB.Intersects(viewAABB))
        while (targets.MoveNext(out var uid, out var comp))
        {
            var dist = (_transform.GetWorldPosition(uid) - drawJob.mapPos.Position).Length();
            var objectName = $"{comp.Name} ({dist:0.0}m)";
            var labelDimensions = handle.GetDimensions(Font, objectName, 1f);
            Vector2 UIPos;
            if (!gridAABB.Intersects(viewAABB))
            {
                UIPos = ResolveUIPosition(
                    drawJob.rot,
                    _transform.GetWorldPosition(uid),
                    drawJob.mapPos.Position,
                    labelDimensions);
            }
            else
            {
                UIPos = (-drawJob.rot).RotateVec(_transform.GetWorldPosition(uid) - drawJob.mapPos.Position);
                UIPos.Y *= -1;
                UIPos = ScalePosition(UIPos);
                UIPos.X -= labelDimensions.X/2;
            }
            UIPos = new Vector2(
                Math.Clamp(UIPos.X, 5f, PixelWidth - labelDimensions.X),
                Math.Clamp(UIPos.Y, 0f, PixelHeight - labelDimensions.Y));

            handle.DrawString(Font, UIPos, objectName, Color.White);
        }
    }

    private void DrawDocks(DrawingHandleScreen handle, EntityUid uid, Matrix3x2 matrix)
    {
        if (!ShowDocks)
            return;

        const float DockScale = 0.6f;
        var nent = EntManager.GetNetEntity(uid);

        if (_docks.TryGetValue(nent, out var docks))
        {
            foreach (var state in docks)
            {
                var position = state.Coordinates.Position;
                var uiPosition = Vector2.Transform(position, matrix);

                if (uiPosition.Length() > (WorldRange * 2f) - DockScale)
                    continue;

                var color = Color.ToSrgb(Color.Magenta);

                var verts = new[]
                {
                    Vector2.Transform(position + new Vector2(-DockScale, -DockScale), matrix),
                    Vector2.Transform(position + new Vector2(DockScale, -DockScale), matrix),
                    Vector2.Transform(position + new Vector2(DockScale, DockScale), matrix),
                    Vector2.Transform(position + new Vector2(-DockScale, DockScale), matrix),
                };

                for (var i = 0; i < verts.Length; i++)
                {
                    var vert = verts[i];
                    vert.Y = -vert.Y;
                    verts[i] = ScalePosition(vert);
                }

                handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, color.WithAlpha(0.8f));
                handle.DrawPrimitives(DrawPrimitiveTopology.LineStrip, verts, color);
            }
        }
    }
    private void DrawProjectiles(DrawingHandleScreen handle, Matrix3x2 matrix)
    {
        foreach (var projectile in _projectiles)
        {
            // Create the visual with the scale passed to the constructor
            var visual = _projectileIFF.GetVisual((ProjectileIFFVisualType)projectile.VisualTypeIndex, projectile.Scale);

            // Call GetVertice without the scale argument
            var verts = visual.GetVertice(projectile.Coordinates.Position, matrix);

            for (var i = 0; i < verts.Length; i++)
            {
                var vert = verts[i];
                vert.Y = -vert.Y;
                verts[i] = ScalePosition(vert);
            }

            handle.DrawPrimitives(visual.Topology, verts, projectile.Color);
        }
    }

    private void DrawTurrets(DrawingHandleScreen handle, EntityUid uid, Matrix3x2 matrix, bool isSelf)
    {
        const float scale = 0.8f;

        var netEntity = EntManager.GetNetEntity(uid);
        if (_turrets.TryGetValue(netEntity, out var turrets))
        {
            foreach (var turret in turrets)
            {
                var position = turret.Coordinates.Position;
                var uiPosition = Vector2.Transform(position, matrix);

                if (uiPosition.Length() > (WorldRange * 2f) - scale)
                {
                    continue;
                }

                var verts = new[]
                {
                    position + new Vector2(-scale, -scale),
                    position + new Vector2(scale, -scale),
                    position + new Vector2(scale, scale),
                    position + new Vector2(-scale, scale),
                };

                for (var i = 0; i < verts.Length; i++)
                {
                    var vert = Vector2.Transform(verts[i], matrix);
                    vert.Y = -vert.Y;
                    verts[i] = ScalePosition(vert);
                }

                Color color;
                if (!isSelf)
                {
                    color = TurretIFFComponent.DefaultColor;
                }
                else if (turret.IsControlled)
                {
                    color = TurretIFFComponent.DefaultControlledColor;
                }
                else
                {
                    color = TurretIFFComponent.DefaultSelfColor;
                }

                handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, color);
            }
        }
    }

    private void DrawShields(DrawingHandleScreen handle, TransformComponent consoleXform, Matrix3x2 matrix)
    {
        var shields = EntManager.AllEntityQueryEnumerator<ShipShieldVisualsComponent, FixturesComponent, TransformComponent>();
        while (shields.MoveNext(out var uid, out var _, out var fixtures, out var xform))
        {
            if (!EntManager.TryGetComponent<TransformComponent>(xform.GridUid, out var parentXform))
                continue;

            if (xform.MapID != consoleXform.MapID)
                continue;

            var shieldFixture = _fixtures.GetFixtureOrNull(uid, "shield", fixtures);

            if (shieldFixture == null || shieldFixture.Shape is not ChainShape)
                continue;

            ChainShape chain = (ChainShape) shieldFixture.Shape;

            var count = chain.Count;
            var verticies = chain.Vertices;

            var center = xform.LocalPosition;

            for (int i = 1; i < count; i++)
            {
                var v1 = Vector2.Add(center, verticies[i - 1]);
                v1 = Vector2.Transform(v1, parentXform.WorldMatrix); // transform to world matrix
                v1 = Vector2.Transform(v1, matrix); // get back to local matrix for drawing
                v1.Y = -v1.Y;
                v1 = ScalePosition(v1);
                var v2 = Vector2.Add(center, verticies[i]);
                v2 = Vector2.Transform(v2, parentXform.WorldMatrix);
                v2 = Vector2.Transform(v2, matrix);
                v2.Y = -v2.Y;
                v2 = ScalePosition(v2);
                handle.DrawLine(v1, v2, Color.Purple);
            }
        }
    }


    private Vector2 InverseScalePosition(Vector2 value)
    {
        return (value - MidPointVector) / MinimapScale;
    }
}
