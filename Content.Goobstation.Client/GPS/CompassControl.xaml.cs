using System.Numerics;
using Content.Goobstation.Shared.GPS;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;

namespace Content.Goobstation.Client.GPS;

[GenerateTypedNameReferences]
public sealed partial class CompassControl : LayoutContainer
{
    [Dependency] private readonly IEyeManager _eyeManager = default!;

    private MapCoordinates _gpsCoordinates;
    private NetEntity? _trackedEntity;
    private List<GpsEntry> _gpsEntries = new();
    private float _zoom = 6f;

    private const float GridLinesPerMeter = 4f;
    private const int GridMetersPerZoom = 16; // GridMetersPerZoom * MaxZoom = 160, an actual maximum range of a compass
    private const float DotRadius = 3f;
    private const float SelectedDotRadius = 6f;
    private const float DistressDotRadius = 5f;

    private const float ScrollSensitivity = 8f;
    public float MinZoom = 1f;
    public float MaxZoom = 10f;

    private float GridLines => GridMetersPerZoom * _zoom;

    public CompassControl()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        MouseFilter = MouseFilterMode.Pass;
    }

    public void SetState(MapCoordinates gpsCoords, NetEntity? trackedEntity, List<GpsEntry> gpsEntries)
    {
        _trackedEntity = trackedEntity;
        _gpsEntries = gpsEntries;
        _gpsCoordinates = gpsCoords;
    }

    public void UpdatePosition(MapCoordinates gpsCoords)
    {
        _gpsCoordinates = gpsCoords;
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        var gridSize = Math.Min(PixelSize.X, PixelSize.Y) * 0.9f;
        var box = UIBox2.FromDimensions(Vector2.Zero, PixelSize);
        var center = box.Center;
        var halfSize = gridSize / 2;

        var gridTopLeft = center - new Vector2(halfSize, halfSize);
        var gridBottomRight = center + new Vector2(halfSize, halfSize);

        // Draw background
        handle.DrawRect(new UIBox2(gridTopLeft, gridBottomRight), Color.Black.WithAlpha(0.5f));

        // Draw grid lines
        var cellStep = gridSize / GridLines * GridLinesPerMeter;
        for (var i = 0; i <= GridLines / GridLinesPerMeter; i++)
        {
            var verticalStart = gridTopLeft + new Vector2(i * cellStep, 0);
            var verticalEnd = verticalStart + new Vector2(0, gridSize);
            handle.DrawLine(verticalStart, verticalEnd, Color.White.WithAlpha(0.2f));

            var horizontalStart = gridTopLeft + new Vector2(0, i * cellStep);
            var horizontalEnd = horizontalStart + new Vector2(gridSize, 0);
            handle.DrawLine(horizontalStart, horizontalEnd, Color.White.WithAlpha(0.2f));
        }

        handle.DrawRect(new UIBox2(gridTopLeft, gridBottomRight), Color.White, false);

        handle.DrawCircle(center, DotRadius, Color.Cyan);

        var gridScale = gridSize / GridLines;

        foreach (var entry in _gpsEntries)
        {
            if (entry.Coordinates.MapId != _gpsCoordinates.MapId)
                continue;

            var worldVec = entry.Coordinates.Position - _gpsCoordinates.Position;

            var screenVec = _eyeManager.CurrentEye.Rotation.RotateVec(worldVec);

            screenVec.Y = -screenVec.Y;

            var gridPos = center + screenVec * gridScale;

            var clampedPos = gridPos;
            clampedPos.X = Math.Clamp(clampedPos.X, gridTopLeft.X, gridBottomRight.X);
            clampedPos.Y = Math.Clamp(clampedPos.Y, gridTopLeft.Y, gridBottomRight.Y);

            var isSelected = _trackedEntity == entry.NetEntity;
            var radius = isSelected
                ? SelectedDotRadius
                : entry.IsDistress
                    ? DistressDotRadius
                    : DotRadius;
            var color = isSelected
                ? Color.Cyan
                : entry.IsDistress
                    ? Color.Pink
                    : Color.Red;

            handle.DrawCircle(clampedPos, radius, color);
        }
    }

    protected override void MouseWheel(GUIMouseWheelEventArgs args)
    {
        base.MouseWheel(args);
        _zoom = Math.Clamp(_zoom - args.Delta.Y * 1f / ScrollSensitivity * _zoom, MinZoom, MaxZoom);
    }
}
